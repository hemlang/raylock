// raylib-hemlock: Raylib bindings for Hemlock
// Uses Hemlock's FFI to call raylib C functions
//
// Usage:
//   Before importing this module, load raylib in your main file:
//   import "/usr/lib/libraylib.so";              // Linux
//   import "/opt/homebrew/opt/raylib/lib/libraylib.dylib";  // macOS (Apple Silicon)
//   import "/usr/local/lib/libraylib.dylib";     // macOS (Intel)
//
// Note: This module provides extern declarations but does NOT load the library.
// The library must be loaded by the application before using these bindings.

// ============================================================================
// Core - Window/Context
// ============================================================================

extern fn InitWindow(width: i32, height: i32, title: string): void;
extern fn CloseWindow(): void;
extern fn WindowShouldClose(): i32;
extern fn IsWindowReady(): i32;
extern fn IsWindowFullscreen(): i32;
extern fn IsWindowHidden(): i32;
extern fn IsWindowMinimized(): i32;
extern fn IsWindowMaximized(): i32;
extern fn IsWindowFocused(): i32;
extern fn IsWindowResized(): i32;
extern fn SetWindowTitle(title: string): void;
extern fn SetWindowPosition(x: i32, y: i32): void;
extern fn SetWindowSize(width: i32, height: i32): void;
extern fn SetWindowMinSize(width: i32, height: i32): void;
extern fn SetWindowMaxSize(width: i32, height: i32): void;
extern fn GetScreenWidth(): i32;
extern fn GetScreenHeight(): i32;
extern fn GetRenderWidth(): i32;
extern fn GetRenderHeight(): i32;
extern fn GetMonitorCount(): i32;
extern fn GetCurrentMonitor(): i32;
extern fn GetMonitorWidth(monitor: i32): i32;
extern fn GetMonitorHeight(monitor: i32): i32;
extern fn GetMonitorRefreshRate(monitor: i32): i32;
extern fn ToggleFullscreen(): void;
extern fn ToggleBorderlessWindowed(): void;
extern fn MaximizeWindow(): void;
extern fn MinimizeWindow(): void;
extern fn RestoreWindow(): void;
extern fn SetWindowOpacity(opacity: f32): void;
extern fn SetTargetFPS(fps: i32): void;
extern fn GetFPS(): i32;
extern fn GetFrameTime(): f32;
extern fn GetTime(): f64;

// ============================================================================
// Core - Drawing
// ============================================================================

// Note: ClearBackground takes Color struct (4 bytes RGBA) passed as u32
extern fn ClearBackground(color: u32): void;
extern fn BeginDrawing(): void;
extern fn EndDrawing(): void;

// Blend modes
extern fn BeginBlendMode(mode: i32): void;
extern fn EndBlendMode(): void;

// Scissor mode (clipping)
extern fn BeginScissorMode(x: i32, y: i32, width: i32, height: i32): void;
extern fn EndScissorMode(): void;

// ============================================================================
// Core - Input: Keyboard
// ============================================================================

extern fn IsKeyPressed(key: i32): i32;
extern fn IsKeyPressedRepeat(key: i32): i32;
extern fn IsKeyDown(key: i32): i32;
extern fn IsKeyReleased(key: i32): i32;
extern fn IsKeyUp(key: i32): i32;
extern fn GetKeyPressed(): i32;
extern fn GetCharPressed(): i32;
extern fn SetExitKey(key: i32): void;

// ============================================================================
// Core - Input: Mouse
// ============================================================================

extern fn IsMouseButtonPressed(button: i32): i32;
extern fn IsMouseButtonDown(button: i32): i32;
extern fn IsMouseButtonReleased(button: i32): i32;
extern fn IsMouseButtonUp(button: i32): i32;
extern fn GetMouseX(): i32;
extern fn GetMouseY(): i32;
extern fn GetMouseWheelMove(): f32;
extern fn SetMousePosition(x: i32, y: i32): void;
extern fn SetMouseOffset(offsetX: i32, offsetY: i32): void;
extern fn SetMouseScale(scaleX: f32, scaleY: f32): void;
extern fn ShowCursor(): void;
extern fn HideCursor(): void;
extern fn IsCursorHidden(): i32;
extern fn EnableCursor(): void;
extern fn DisableCursor(): void;
extern fn IsCursorOnScreen(): i32;

// ============================================================================
// Core - Input: Gamepad
// ============================================================================

extern fn IsGamepadAvailable(gamepad: i32): i32;
extern fn GetGamepadName(gamepad: i32): string;
extern fn IsGamepadButtonPressed(gamepad: i32, button: i32): i32;
extern fn IsGamepadButtonDown(gamepad: i32, button: i32): i32;
extern fn IsGamepadButtonReleased(gamepad: i32, button: i32): i32;
extern fn IsGamepadButtonUp(gamepad: i32, button: i32): i32;
extern fn GetGamepadButtonPressed(): i32;
extern fn GetGamepadAxisCount(gamepad: i32): i32;
extern fn GetGamepadAxisMovement(gamepad: i32, axis: i32): f32;
extern fn SetGamepadMappings(mappings: string): i32;

// ============================================================================
// Core - Input: Touch
// ============================================================================

extern fn GetTouchX(): i32;
extern fn GetTouchY(): i32;
extern fn GetTouchPointId(index: i32): i32;
extern fn GetTouchPointCount(): i32;

// ============================================================================
// Core - Gestures
// ============================================================================

extern fn SetGesturesEnabled(flags: u32): void;
extern fn IsGestureDetected(gesture: u32): i32;
extern fn GetGestureDetected(): i32;
extern fn GetGestureHoldDuration(): f32;
extern fn GetGestureDragAngle(): f32;
extern fn GetGesturePinchAngle(): f32;

// ============================================================================
// Shapes - Basic Drawing
// ============================================================================

extern fn DrawPixel(posX: i32, posY: i32, color: u32): void;
extern fn DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: u32): void;
extern fn DrawLineEx(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, thick: f32, color: u32): void;
extern fn DrawCircle(centerX: i32, centerY: i32, radius: f32, color: u32): void;
extern fn DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, color1: u32, color2: u32): void;
extern fn DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: u32): void;
extern fn DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: u32): void;
extern fn DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: u32): void;
extern fn DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: u32): void;
extern fn DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, color1: u32, color2: u32): void;
extern fn DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, color1: u32, color2: u32): void;
extern fn DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: u32): void;
extern fn DrawTriangle(v1x: i32, v1y: i32, v2x: i32, v2y: i32, v3x: i32, v3y: i32, color: u32): void;
extern fn DrawTriangleLines(v1x: i32, v1y: i32, v2x: i32, v2y: i32, v3x: i32, v3y: i32, color: u32): void;

// ============================================================================
// Text - Drawing
// ============================================================================

extern fn DrawText(text: string, posX: i32, posY: i32, fontSize: i32, color: u32): void;
extern fn MeasureText(text: string, fontSize: i32): i32;

// ============================================================================
// Audio - Device Management
// ============================================================================

extern fn InitAudioDevice(): void;
extern fn CloseAudioDevice(): void;
extern fn IsAudioDeviceReady(): i32;
extern fn SetMasterVolume(volume: f32): void;
extern fn GetMasterVolume(): f32;

// ============================================================================
// Color Constants (RGBA packed as u32 - little endian: ABGR in memory)
// ============================================================================

// On little-endian systems, Color struct {r,g,b,a} maps to memory as r,g,b,a
// When read as u32: a<<24 | b<<16 | g<<8 | r
export fn Color(r: u8, g: u8, b: u8, a: u8): u32 {
    let r32: u32 = r;
    let g32: u32 = g;
    let b32: u32 = b;
    let a32: u32 = a;
    return (a32 << 24) | (b32 << 16) | (g32 << 8) | r32;
}

// Color manipulation helpers
export fn ColorAlpha(color: u32, alpha: f32): u32 {
    let a: u32 = alpha * 255.0;
    if (a > 255) { a = 255; }
    return (color & 0x00FFFFFF) | (a << 24);
}

export fn ColorBrightness(color: u32, factor: f32): u32 {
    let r: u32 = color & 0xFF;
    let g: u32 = (color >> 8) & 0xFF;
    let b: u32 = (color >> 16) & 0xFF;
    let a: u32 = (color >> 24) & 0xFF;

    let nr: i32 = r * factor;
    let ng: i32 = g * factor;
    let nb: i32 = b * factor;

    if (nr > 255) { nr = 255; }
    if (ng > 255) { ng = 255; }
    if (nb > 255) { nb = 255; }
    if (nr < 0) { nr = 0; }
    if (ng < 0) { ng = 0; }
    if (nb < 0) { nb = 0; }

    return Color(nr, ng, nb, a);
}

// Extract color components
export fn ColorGetR(color: u32): u8 {
    return color & 0xFF;
}

export fn ColorGetG(color: u32): u8 {
    return (color >> 8) & 0xFF;
}

export fn ColorGetB(color: u32): u8 {
    return (color >> 16) & 0xFF;
}

export fn ColorGetA(color: u32): u8 {
    return (color >> 24) & 0xFF;
}

// Standard colors
export let LIGHTGRAY: u32  = Color(200, 200, 200, 255);
export let GRAY: u32       = Color(130, 130, 130, 255);
export let DARKGRAY: u32   = Color(80, 80, 80, 255);
export let YELLOW: u32     = Color(253, 249, 0, 255);
export let GOLD: u32       = Color(255, 203, 0, 255);
export let ORANGE: u32     = Color(255, 161, 0, 255);
export let PINK: u32       = Color(255, 109, 194, 255);
export let RED: u32        = Color(230, 41, 55, 255);
export let MAROON: u32     = Color(190, 33, 55, 255);
export let GREEN: u32      = Color(0, 228, 48, 255);
export let LIME: u32       = Color(0, 158, 47, 255);
export let DARKGREEN: u32  = Color(0, 117, 44, 255);
export let SKYBLUE: u32    = Color(102, 191, 255, 255);
export let BLUE: u32       = Color(0, 121, 241, 255);
export let DARKBLUE: u32   = Color(0, 82, 172, 255);
export let PURPLE: u32     = Color(200, 122, 255, 255);
export let VIOLET: u32     = Color(135, 60, 190, 255);
export let DARKPURPLE: u32 = Color(112, 31, 126, 255);
export let BEIGE: u32      = Color(211, 176, 131, 255);
export let BROWN: u32      = Color(127, 106, 79, 255);
export let DARKBROWN: u32  = Color(76, 63, 47, 255);
export let WHITE: u32      = Color(255, 255, 255, 255);
export let BLACK: u32      = Color(0, 0, 0, 255);
export let BLANK: u32      = Color(0, 0, 0, 0);
export let MAGENTA: u32    = Color(255, 0, 255, 255);
export let RAYWHITE: u32   = Color(245, 245, 245, 255);

// ============================================================================
// Key Constants
// ============================================================================

export let KEY_NULL: i32        = 0;
export let KEY_APOSTROPHE: i32  = 39;
export let KEY_COMMA: i32       = 44;
export let KEY_MINUS: i32       = 45;
export let KEY_PERIOD: i32      = 46;
export let KEY_SLASH: i32       = 47;
export let KEY_ZERO: i32        = 48;
export let KEY_ONE: i32         = 49;
export let KEY_TWO: i32         = 50;
export let KEY_THREE: i32       = 51;
export let KEY_FOUR: i32        = 52;
export let KEY_FIVE: i32        = 53;
export let KEY_SIX: i32         = 54;
export let KEY_SEVEN: i32       = 55;
export let KEY_EIGHT: i32       = 56;
export let KEY_NINE: i32        = 57;
export let KEY_SEMICOLON: i32   = 59;
export let KEY_EQUAL: i32       = 61;
export let KEY_A: i32           = 65;
export let KEY_B: i32           = 66;
export let KEY_C: i32           = 67;
export let KEY_D: i32           = 68;
export let KEY_E: i32           = 69;
export let KEY_F: i32           = 70;
export let KEY_G: i32           = 71;
export let KEY_H: i32           = 72;
export let KEY_I: i32           = 73;
export let KEY_J: i32           = 74;
export let KEY_K: i32           = 75;
export let KEY_L: i32           = 76;
export let KEY_M: i32           = 77;
export let KEY_N: i32           = 78;
export let KEY_O: i32           = 79;
export let KEY_P: i32           = 80;
export let KEY_Q: i32           = 81;
export let KEY_R: i32           = 82;
export let KEY_S: i32           = 83;
export let KEY_T: i32           = 84;
export let KEY_U: i32           = 85;
export let KEY_V: i32           = 86;
export let KEY_W: i32           = 87;
export let KEY_X: i32           = 88;
export let KEY_Y: i32           = 89;
export let KEY_Z: i32           = 90;
export let KEY_LEFT_BRACKET: i32  = 91;
export let KEY_BACKSLASH: i32     = 92;
export let KEY_RIGHT_BRACKET: i32 = 93;
export let KEY_GRAVE: i32         = 96;
export let KEY_SPACE: i32       = 32;
export let KEY_ESCAPE: i32      = 256;
export let KEY_ENTER: i32       = 257;
export let KEY_TAB: i32         = 258;
export let KEY_BACKSPACE: i32   = 259;
export let KEY_INSERT: i32      = 260;
export let KEY_DELETE: i32      = 261;
export let KEY_RIGHT: i32       = 262;
export let KEY_LEFT: i32        = 263;
export let KEY_DOWN: i32        = 264;
export let KEY_UP: i32          = 265;
export let KEY_PAGE_UP: i32     = 266;
export let KEY_PAGE_DOWN: i32   = 267;
export let KEY_HOME: i32        = 268;
export let KEY_END: i32         = 269;
export let KEY_CAPS_LOCK: i32   = 280;
export let KEY_SCROLL_LOCK: i32 = 281;
export let KEY_NUM_LOCK: i32    = 282;
export let KEY_PRINT_SCREEN: i32 = 283;
export let KEY_PAUSE: i32       = 284;
export let KEY_F1: i32          = 290;
export let KEY_F2: i32          = 291;
export let KEY_F3: i32          = 292;
export let KEY_F4: i32          = 293;
export let KEY_F5: i32          = 294;
export let KEY_F6: i32          = 295;
export let KEY_F7: i32          = 296;
export let KEY_F8: i32          = 297;
export let KEY_F9: i32          = 298;
export let KEY_F10: i32         = 299;
export let KEY_F11: i32         = 300;
export let KEY_F12: i32         = 301;
export let KEY_LEFT_SHIFT: i32  = 340;
export let KEY_LEFT_CONTROL: i32 = 341;
export let KEY_LEFT_ALT: i32    = 342;
export let KEY_LEFT_SUPER: i32  = 343;
export let KEY_RIGHT_SHIFT: i32 = 344;
export let KEY_RIGHT_CONTROL: i32 = 345;
export let KEY_RIGHT_ALT: i32   = 346;
export let KEY_RIGHT_SUPER: i32 = 347;
export let KEY_KB_MENU: i32     = 348;

// Keypad keys
export let KEY_KP_0: i32        = 320;
export let KEY_KP_1: i32        = 321;
export let KEY_KP_2: i32        = 322;
export let KEY_KP_3: i32        = 323;
export let KEY_KP_4: i32        = 324;
export let KEY_KP_5: i32        = 325;
export let KEY_KP_6: i32        = 326;
export let KEY_KP_7: i32        = 327;
export let KEY_KP_8: i32        = 328;
export let KEY_KP_9: i32        = 329;
export let KEY_KP_DECIMAL: i32  = 330;
export let KEY_KP_DIVIDE: i32   = 331;
export let KEY_KP_MULTIPLY: i32 = 332;
export let KEY_KP_SUBTRACT: i32 = 333;
export let KEY_KP_ADD: i32      = 334;
export let KEY_KP_ENTER: i32    = 335;
export let KEY_KP_EQUAL: i32    = 336;

// ============================================================================
// Mouse Button Constants
// ============================================================================

export let MOUSE_BUTTON_LEFT: i32    = 0;
export let MOUSE_BUTTON_RIGHT: i32   = 1;
export let MOUSE_BUTTON_MIDDLE: i32  = 2;
export let MOUSE_BUTTON_SIDE: i32    = 3;
export let MOUSE_BUTTON_EXTRA: i32   = 4;
export let MOUSE_BUTTON_FORWARD: i32 = 5;
export let MOUSE_BUTTON_BACK: i32    = 6;

// ============================================================================
// Mouse Cursor Constants
// ============================================================================

export let MOUSE_CURSOR_DEFAULT: i32       = 0;
export let MOUSE_CURSOR_ARROW: i32         = 1;
export let MOUSE_CURSOR_IBEAM: i32         = 2;
export let MOUSE_CURSOR_CROSSHAIR: i32     = 3;
export let MOUSE_CURSOR_POINTING_HAND: i32 = 4;
export let MOUSE_CURSOR_RESIZE_EW: i32     = 5;
export let MOUSE_CURSOR_RESIZE_NS: i32     = 6;
export let MOUSE_CURSOR_RESIZE_NWSE: i32   = 7;
export let MOUSE_CURSOR_RESIZE_NESW: i32   = 8;
export let MOUSE_CURSOR_RESIZE_ALL: i32    = 9;
export let MOUSE_CURSOR_NOT_ALLOWED: i32   = 10;

// ============================================================================
// Gamepad Constants
// ============================================================================

export let GAMEPAD_BUTTON_UNKNOWN: i32          = 0;
export let GAMEPAD_BUTTON_LEFT_FACE_UP: i32     = 1;
export let GAMEPAD_BUTTON_LEFT_FACE_RIGHT: i32  = 2;
export let GAMEPAD_BUTTON_LEFT_FACE_DOWN: i32   = 3;
export let GAMEPAD_BUTTON_LEFT_FACE_LEFT: i32   = 4;
export let GAMEPAD_BUTTON_RIGHT_FACE_UP: i32    = 5;
export let GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: i32 = 6;
export let GAMEPAD_BUTTON_RIGHT_FACE_DOWN: i32  = 7;
export let GAMEPAD_BUTTON_RIGHT_FACE_LEFT: i32  = 8;
export let GAMEPAD_BUTTON_LEFT_TRIGGER_1: i32   = 9;
export let GAMEPAD_BUTTON_LEFT_TRIGGER_2: i32   = 10;
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_1: i32  = 11;
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_2: i32  = 12;
export let GAMEPAD_BUTTON_MIDDLE_LEFT: i32      = 13;
export let GAMEPAD_BUTTON_MIDDLE: i32           = 14;
export let GAMEPAD_BUTTON_MIDDLE_RIGHT: i32     = 15;
export let GAMEPAD_BUTTON_LEFT_THUMB: i32       = 16;
export let GAMEPAD_BUTTON_RIGHT_THUMB: i32      = 17;

export let GAMEPAD_AXIS_LEFT_X: i32        = 0;
export let GAMEPAD_AXIS_LEFT_Y: i32        = 1;
export let GAMEPAD_AXIS_RIGHT_X: i32       = 2;
export let GAMEPAD_AXIS_RIGHT_Y: i32       = 3;
export let GAMEPAD_AXIS_LEFT_TRIGGER: i32  = 4;
export let GAMEPAD_AXIS_RIGHT_TRIGGER: i32 = 5;

// ============================================================================
// Gesture Constants
// ============================================================================

export let GESTURE_NONE: u32        = 0;
export let GESTURE_TAP: u32         = 1;
export let GESTURE_DOUBLETAP: u32   = 2;
export let GESTURE_HOLD: u32        = 4;
export let GESTURE_DRAG: u32        = 8;
export let GESTURE_SWIPE_RIGHT: u32 = 16;
export let GESTURE_SWIPE_LEFT: u32  = 32;
export let GESTURE_SWIPE_UP: u32    = 64;
export let GESTURE_SWIPE_DOWN: u32  = 128;
export let GESTURE_PINCH_IN: u32    = 256;
export let GESTURE_PINCH_OUT: u32   = 512;

// ============================================================================
// Blend Mode Constants
// ============================================================================

export let BLEND_ALPHA: i32             = 0;
export let BLEND_ADDITIVE: i32          = 1;
export let BLEND_MULTIPLIED: i32        = 2;
export let BLEND_ADD_COLORS: i32        = 3;
export let BLEND_SUBTRACT_COLORS: i32   = 4;
export let BLEND_ALPHA_PREMULTIPLY: i32 = 5;
export let BLEND_CUSTOM: i32            = 6;
export let BLEND_CUSTOM_SEPARATE: i32   = 7;

// ============================================================================
// Collision Detection Helpers
// ============================================================================

// Check collision between two circles (coordinate-based)
export fn CheckCollisionCirclesXY(c1x: f32, c1y: f32, r1: f32, c2x: f32, c2y: f32, r2: f32): i32 {
    let dx = c2x - c1x;
    let dy = c2y - c1y;
    let distSq = dx * dx + dy * dy;
    let radiusSum = r1 + r2;
    if (distSq <= radiusSum * radiusSum) {
        return 1;
    }
    return 0;
}

// Check collision between two rectangles (coordinate-based)
export fn CheckCollisionRectsXY(x1: f32, y1: f32, w1: f32, h1: f32, x2: f32, y2: f32, w2: f32, h2: f32): i32 {
    if (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2) {
        return 1;
    }
    return 0;
}

// Check collision between point and rectangle
export fn CheckCollisionPointRectXY(px: f32, py: f32, rx: f32, ry: f32, rw: f32, rh: f32): i32 {
    if (px >= rx && px <= rx + rw && py >= ry && py <= ry + rh) {
        return 1;
    }
    return 0;
}

// Check collision between point and circle
export fn CheckCollisionPointCircleXY(px: f32, py: f32, cx: f32, cy: f32, r: f32): i32 {
    let dx = px - cx;
    let dy = py - cy;
    let distSq = dx * dx + dy * dy;
    if (distSq <= r * r) {
        return 1;
    }
    return 0;
}

// Check collision between circle and rectangle
export fn CheckCollisionCircleRecXY(cx: f32, cy: f32, r: f32, rx: f32, ry: f32, rw: f32, rh: f32): i32 {
    // Find closest point on rectangle to circle center
    let closestX = cx;
    let closestY = cy;

    if (cx < rx) { closestX = rx; }
    else if (cx > rx + rw) { closestX = rx + rw; }

    if (cy < ry) { closestY = ry; }
    else if (cy > ry + rh) { closestY = ry + rh; }

    let dx = cx - closestX;
    let dy = cy - closestY;
    let distSq = dx * dx + dy * dy;

    if (distSq <= r * r) {
        return 1;
    }
    return 0;
}

// ============================================================================
// Utility Functions
// ============================================================================

// Vector2 distance
export fn Vector2Distance(x1: f32, y1: f32, x2: f32, y2: f32): f32 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return sqrt(dx * dx + dy * dy);
}

// Vector2 length
export fn Vector2Length(x: f32, y: f32): f32 {
    return sqrt(x * x + y * y);
}

// Vector2 dot product
export fn Vector2Dot(x1: f32, y1: f32, x2: f32, y2: f32): f32 {
    return x1 * x2 + y1 * y2;
}

// Lerp helper
export fn Lerp(start: f32, end: f32, amount: f32): f32 {
    return start + amount * (end - start);
}

// Clamp helper
export fn Clamp(value: f32, min: f32, max: f32): f32 {
    if (value < min) { return min; }
    if (value > max) { return max; }
    return value;
}

// Clamp integer helper
export fn ClampInt(value: i32, min: i32, max: i32): i32 {
    if (value < min) { return min; }
    if (value > max) { return max; }
    return value;
}

// Remap value from one range to another
export fn Remap(value: f32, inputStart: f32, inputEnd: f32, outputStart: f32, outputEnd: f32): f32 {
    return outputStart + (value - inputStart) / (inputEnd - inputStart) * (outputEnd - outputStart);
}

// Wrap value within range [min, max)
export fn Wrap(value: f32, min: f32, max: f32): f32 {
    let range = max - min;
    let result = value - min;
    while (result < 0.0) { result = result + range; }
    while (result >= range) { result = result - range; }
    return result + min;
}

// Normalize angle to [0, 360)
export fn NormalizeAngle(angle: f32): f32 {
    let result = angle;
    while (result < 0.0) { result = result + 360.0; }
    while (result >= 360.0) { result = result - 360.0; }
    return result;
}

// Degrees to radians
export fn Deg2Rad(degrees: f32): f32 {
    return degrees * 0.01745329251994329577;
}

// Radians to degrees
export fn Rad2Deg(radians: f32): f32 {
    return radians * 57.29577951308232087680;
}
